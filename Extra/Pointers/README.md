
# Pointers in C / C++
![](https://i.ytimg.com/vi/zuegQmMdy8M/maxresdefault.jpg)


## Introduction to pointers in C/C [(00:00:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=0s)
- To comprehend pointers, it's essential to know how various data types or variables are stored in a computer's memory, specifically in the [Random-access memory](https://en.wikipedia.org/wiki/Random-access_memory) (RAM) [(00:00:47)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=47s).
- In a typical computer architecture, each byte of memory has a unique address, with addresses increasing sequentially, such as 0, 1, 2, and so on [(00:01:33)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=93s).
- When a variable is declared in a program, the computer allocates a specific amount of memory based on the data type and compiler, for example, an integer typically occupies four bytes of memory [(00:02:08)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=128s).
- The computer stores information about the variable, including its data type and memory address, in an internal structure called a lookup table [(00:03:07)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=187s).
- When performing operations with variables, the computer refers to the lookup table to locate the variable's memory address and perform the necessary actions, such as writing a value to that address [(00:03:53)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=233s).
- The value written to memory is stored in binary format, but for simplicity, it's often represented in decimal or other formats for understanding [(00:04:21)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=261s).
- In a computer program, variables are stored in memory locations with specific addresses, and when a variable is modified, the computer looks for its address and changes the value at that location [(00:04:27)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=267s).
- Pointers are variables that store the address of another variable, allowing the program to operate on memory addresses [(00:05:04)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=304s).
- A pointer variable is declared by writing the data type and the variable name with an asterisk sign before the variable, indicating that it points to another variable [(00:06:33)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=393s).
- To store the address of a variable in a pointer, the address-of operator (&) is used, which returns the address of the variable [(00:06:59)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=419s).
- The address-of operator (&) can be used to print the address of a variable, and the asterisk sign (*) can be used to print the value at the location pointed to by a pointer [(00:07:57)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=477s).
- When a pointer is printed, it displays the address it stores, and when the address-of operator is used with a pointer, it displays the address of the pointer itself [(00:08:12)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=492s).
- [Indirection](https://en.wikipedia.org/wiki/Indirection) a pointer, which involves putting an asterisk sign in front of the pointer, gives the value at the location that the pointer points to [(00:08:34)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=514s).
- Dereferencing is a concept that allows the program to access the value stored at the memory location pointed to by a pointer [(00:08:44)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=524s).
- A pointer variable holds an address, and the value at that address can be obtained using the asterisk operator, allowing for modification of the value at that location [(00:08:59)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=539s).
- Modifying the value at the address stored in a pointer variable affects the original variable, as demonstrated by changing the value at address P to 8 and printing the updated value [(00:09:12)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=552s).
- The value of a pointer variable (P) represents the address, while the asterisk operator (*) is used to access the value at that address, denoted as *P [(00:09:30)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=570s).
- A pointer variable is defined by placing an asterisk sign (*) in front of the variable name, and the ampersand sign (&) is used to obtain the address of a variable [(00:09:38)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=578s).
- Operating on a pointer variable without the asterisk operator (*) involves working with the address, whereas using the asterisk operator (*) allows for operations on the value at that address [(00:09:54)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=594s).
- Future lessons will cover common errors when using pointers, pointer arithmetic, and the use of pointers in the context of arrays [(00:10:10)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=610s).

## Working with pointers [(00:10:29)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=629s)
- Pointers are variables that store the address of other variables, and they are declared with a syntax that includes the data type and an asterisk sign followed by the variable name [(00:10:36)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=636s).
- The type of pointer variable used depends on the type of variable it will store the address of, such as an [Const (computer programming)](https://en.wikipedia.org/wiki/Const_(computer_programming)) to store the address of an integer variable, a character pointer to store the address of a character variable, and so on [(00:11:05)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=665s).
- Pointers can also be used to store the address of user-defined structures or classes [(00:11:30)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=690s).
- To get the address of a variable, the ampersand operator is used, and this address is then stored in the pointer variable [(00:11:38)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=698s).
- The value of the variable being pointed to can be accessed using the star operator in front of the pointer variable [(00:12:08)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=728s).
- If a pointer is not initialized before use, it will result in an error, as the program will try to access a garbage value [(00:13:01)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=781s).
- Initializing a pointer with the address of a variable using the ampersand operator allows the pointer to access the value of that variable [(00:13:22)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=802s).
- Printing the value of a pointer using the star operator will give the value of the variable being pointed to, while printing the pointer itself will give its address [(00:13:45)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=825s).
- Initializing the variable being pointed to will ensure that the pointer accesses the correct value, rather than a garbage value [(00:14:30)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=870s).
- The ampersand operator can be used to print the address of a variable, which should match the address stored in the pointer variable [(00:14:43)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=883s).
- [Indirection](https://en.wikipedia.org/wiki/Indirection) is a concept where the value at the address pointed by a pointer is accessed or modified, and it is denoted by the asterisk symbol (*), for example, "*p = 12" means the value at the address pointed by p is now 12 [(00:15:13)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=913s).
- Modifying the value at the address pointed by a pointer does not change the address itself, unless explicitly assigned, for example, "*p = b" only changes the value at the address pointed by p to the value of b, but p still points to the original address [(00:16:09)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=969s).
- The address of a pointer variable and its value can be printed using printf statements, and it can be seen that modifying the value at the address pointed by a pointer does not change the address itself [(00:16:48)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1008s).
- Pointer variables can be declared and initialized in the same statement, for example, "int *p = &a" is equivalent to declaring "int *p" and then initializing "p = &a" [(00:17:21)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1041s).
- The syntax of declaring pointers can vary, with some people writing the asterisk sign after the type and not in front of the variable name, for example, "int* p" is equivalent to "int *p" [(00:17:38)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1058s).
- Pointer arithmetic is a concept that allows pointer variables to be incremented or decremented, and it is possible to do so, but the result depends on the type of the pointer, for example, incrementing an [Const (computer programming)](https://en.wikipedia.org/wiki/Const_(computer_programming)) by one unit takes us to the address of the next integer, which is four bytes away [(00:18:27)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1107s).
- The size of the data type pointed to by a pointer determines how much the pointer is incremented or decremented, for example, incrementing an integer pointer by one unit increments the address by four bytes, which is the size of an integer [(00:19:01)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1141s).
- The size of an integer can be determined using the sizeof function, which returns the size of a data type in bytes, and for a particular compiler, the size of an integer is four bytes [(00:19:22)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1162s).
- When a pointer p is incremented by one, the address it points to is increased by the size of the data type it points to, in this case, four bytes for an integer [(00:19:36)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1176s).
- Incrementing a pointer by two increases the address by twice the size of the data type, so for an integer, it would be eight bytes [(00:20:10)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1210s).
- To print the value at a particular address, the dereference operator * is used before the pointer, and the output will be the value stored at that address [(00:20:39)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1239s).
- When printing the value at p + 1, the output may be a garbage value because there is no integer allocated to that particular memory address [(00:21:07)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1267s).
- Using pointer arithmetic and manipulation can be dangerous in C, as it allows access to any address and may result in unwanted behavior [(00:21:24)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1284s).
- The results of these operations will be similar when tried with other data types, such as characters or floats [(00:21:41)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1301s).
- Pointers will be discussed further in the context of arrays in future lessons [(00:21:53)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1313s).

## Pointer types, pointer arithmetic, void pointers [(00:22:05)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1325s)
- Pointer variables are strongly typed, meaning a pointer variable of a specific type is required to store the address of a variable of the same type, such as an [Const (computer programming)](https://en.wikipedia.org/wiki/Const_(computer_programming)) for an integer variable and a character pointer for a character variable [(00:22:23)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1343s).
- The strong typing of pointer variables is necessary because pointers are not only used to store memory addresses but also to dereference these addresses to access and modify the values stored at these addresses [(00:23:08)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1388s).
- Different data types have varying sizes, such as integers typically being stored in four bytes and characters in one byte, and they also differ in how information is stored within these bytes [(00:23:22)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1402s).
- When a variable is stored in memory, its bytes must be contiguous, and each byte is addressable, with the address of the first byte being used to represent the variable's address in memory [(00:24:13)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1453s).
- Integers are represented in memory with the leftmost bit indicating whether the integer is positive or negative, and the remaining bits storing the value [(00:24:27)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1467s).
- When a pointer to an integer is used to store the address of an integer variable, [Indirection](https://en.wikipedia.org/wiki/Indirection) the pointer will retrieve the value stored at that address by examining the four bytes starting at the stored address [(00:25:30)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1530s).
- The type of pointer used affects how the machine retrieves the value when dereferencing the pointer, with a character pointer examining only one byte and a float pointer examining four bytes but interpreting the information differently than an [Const (computer programming)](https://en.wikipedia.org/wiki/Const_(computer_programming)) [(00:26:01)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1561s).
- A C program is written to declare an integer A equal to 1025 and a pointer to integer P, which stores the address of A using the ampersand operator, and then prints the size of the integer and the address and value of P. [(00:26:28)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1588s)
- The output of the program shows the size of the integer is four bytes, and the address and value of P are printed as expected. [(00:27:14)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1634s)
- A character pointer P0 is declared and assigned the same address as P, but this requires typecasting P to a character pointer to avoid a compilation error. [(00:27:25)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1645s)
- The program then prints the size of the character and the address and value of P0, showing that the size of the character is one byte and the address is the same as P, but the value is different due to the typecasting. [(00:27:52)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1672s)
- The value of P0 is one because when the address of P is stored in P0, the rightmost byte is stored, and when P0 is dereferenced, the machine only looks at one byte to see the value. [(00:28:51)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1731s)
- The program then prints the address and value of P+1 and P0+1, demonstrating pointer arithmetic by adding one to the pointers, which increments the address by the size of the data type. [(00:29:20)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1760s)
- The output of the program shows that P+1 increments the address by four bytes, which is the size of the integer, and P0+1 increments the address by one byte, which is the size of the character. [(00:29:58)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1798s)
- When [Indirection](https://en.wikipedia.org/wiki/Indirection) a pointer variable using the [Asterix](https://en.wikipedia.org/wiki/Asterix) operator, the value obtained is the value stored in the memory address the pointer points to, which can be a garbage value if the memory location has not been initialized [(00:30:27)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1827s).
- Pointer arithmetic operations, such as adding 1 to a character pointer, will move the pointer to the next memory location, which is one byte ahead, because characters are stored in one byte [(00:30:45)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1845s).
- The typecasting of a pointer variable from one type to another has use cases, which will be discussed later, and this typecasting can be done explicitly or implicitly in some cases [(00:31:19)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1879s).
- A void pointer is a generic pointer type that does not correspond to a particular data type and is declared using the keyword "void" and an Asterix sign in front of the variable name [(00:31:32)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1892s).
- Void pointers can be assigned a value from another pointer type without explicit typecasting, but they cannot be dereferenced because they are not mapped to a particular data type [(00:31:51)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1911s).
- Void pointers can only be used to print the address they point to, and performing arithmetic operations on them is not possible and will result in a compilation error [(00:32:10)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1930s).
- The use cases of void pointers will be discussed in forthcoming lessons, but for now, it is essential to know that void pointers exist and have specific properties [(00:32:41)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1961s).

## Pointers to Pointers in C/C [(00:33:01)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1981s)
- Pointers can be puzzling in certain scenarios, such as when using pointers to pointers, which is the focus of this lesson [(00:33:05)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1985s).
- In computer memory, each byte has an address, and addresses increase as you move from left to right, with each byte allocated a unique address [(00:33:39)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2019s).
- When an integer variable 'x' is declared and initialized, a typical architecture allocates four bytes of memory to store the integer value, and the address of 'x' can be stored in a pointer variable 'p' [(00:33:53)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2033s).
- To declare a pointer variable 'p' that stores the address of 'x', an asterisk sign is used in front of the variable name, and 'p' must be of type pointer to integer to store the address of 'x' [(00:34:37)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2077s).
- The ampersand operator is used to get the address of a variable, and the address of 'x' is stored in 'p' using the statement 'p = &x' [(00:35:10)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2110s).
- Pointer variables are strongly typed, meaning 'p' must be a pointer to integer to store the address of 'x', and cannot be a pointer to character or another type [(00:35:24)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2124s).
- A pointer to a pointer can be created to store the address of 'p', and the type of this variable 'q' is a pointer to pointers, denoted by two asterisk signs in front of the variable name [(00:36:29)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2189s).
- The variable 'q' can store the address of 'p', and 'q' points to 'p' with the type 'int ' [(00:37:08)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2228s).
- To store the address of a variable, a pointer of the same type as the variable is needed, with the type indicated by an asterisk (*), for example, int* for an integer variable [(00:37:27)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2247s).
- Multiple levels of pointers can be declared by adding more asterisks, such as int for a pointer to a pointer to an integer, and int* for a pointer to a pointer to a pointer to an integer [(00:37:52)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2272s).
- The position of the asterisk in a pointer declaration can be before the variable name or immediately after the type, for example, int* p or int *p [(00:38:03)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2283s).
- A pointer to a pointer to a pointer (int* r) can store the address of a pointer to a pointer (int q), but not the address of a pointer (int* p) or a variable (int x) [(00:38:14)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2294s).
- The address stored in a pointer can be accessed using the ampersand (&) operator, and the value stored at that address can be accessed using the asterisk (*) operator [(00:39:05)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2345s).
- Multiple levels of [Indirection](https://en.wikipedia.org/wiki/Indirection) can be performed using multiple asterisks, such as q to access the value stored at the address stored in q, and *r to access the value stored at the address stored in the address stored in r [(00:39:32)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2372s).
- It is a good practice to use parentheses when using the asterisk operator to avoid unwanted behavior, especially when using other operators [(00:40:05)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2405s).
- The value stored in a variable can be modified using a chain of dereferencing, as demonstrated by modifying the value of x using the variable r [(00:41:34)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2494s).
- Asterisk P and asterisk Q are referencing and dereferencing variable x, respectively. [(00:41:52)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2512s)
- The output of the last print statement is related to the increment of variable x by two. [(00:41:59)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2519s)
- The concept discussed is a "pointer to pointer", which will be used in real problem scenarios in future lessons. [(00:42:05)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2525s)
- It is recommended to practice writing code using pointers to pointers to gain a better understanding. [(00:42:10)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2530s)

## Pointers as function arguments - call by reference [(00:42:21)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2541s)
- In C or [C++](https://en.wikipedia.org/wiki/C++) programs, pointer variables have real use cases, such as using pointers as function arguments, also known as "call by reference" [(00:42:48)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2568s).
- A beginner programmer, Albert, tries to apply the concept of user-defined functions by writing a simple C program to increment the value of an integer variable by one using a function called "increment" [(00:42:56)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2576s).
- However, when Albert runs the program, the output is not as expected, and the value of the variable "a" remains 10 instead of being incremented to 11 [(00:43:57)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2637s).
- This is because when a variable is declared inside a function, it becomes a local variable and can only be accessed within that function, so the "a" in the "increment" function and the "a" in the "main" function are not the same [(00:44:37)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2677s).
- When the "main" function calls the "increment" function and passes the value of "a" as an argument, only the value of "a" is copied to another local variable "a" in the "increment" function, not the actual variable "a" in the "main" function [(00:45:06)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2706s).
- To demonstrate this, two print statements are added to the code to print the addresses of the variable "a" in the "increment" and "main" functions, showing that the addresses are different [(00:45:28)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2728s).
- The output of the print statements shows that the addresses of the variable "a" in the "increment" and "main" functions are different, indicating that they are not the same variable [(00:46:10)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2770s).
- When a program or application is started, the computer sets aside a certain amount of memory for its execution, which is typically divided into four parts: text segment for storing instructions, global variable segment for static or global variables, stack segment for local variables, and heap segment for dynamic memory allocation [(00:47:07)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2827s).
- Global variables are allocated in the global variable segment and can be accessed and modified anywhere in the program, whereas local variables are allocated in the stack segment and can only be accessed and modified within a particular function or code block [(00:47:46)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2866s).
- The stack segment is where local variables are stored, and it is a crucial part of the application's memory, with each function having its own stack frame that contains information about the method call, parameters, local variables, and the current instruction being executed [(00:48:06)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2886s).
- The heap segment is used for dynamic memory allocation and can be expanded or contracted during the program's execution, whereas the text segment, global variable segment, and stack segment are fixed and decided when the program starts executing [(00:48:28)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=2908s).
- When a function is invoked, a stack frame is created, and memory is allocated for local variables, with the current instruction being executed and the calling function being stored in the stack frame [(00:50:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3000s).
- When a function calls another function, the machine stops the execution of the first function, allocates a new stack frame for the second function, and copies the parameters and their values to the new stack frame [(00:50:40)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3040s).
- Local variables are created in the new stack frame, and the values passed to the function are copied to these variables, allowing the function to access and modify them [(00:50:51)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3051s).
- The lifetime of a local variable is until the time the function is executing, and once the function finishes, the control returns to the main method, and the stack frame is cleared [(00:51:27)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3087s).
- When a function calls another function, the state of execution of the calling function is paused, and the called function starts executing, with the call stack or function call stack determining which function is currently executing [(00:51:49)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3109s).
- If a function calls another function in an infinite recursion, the memory of the call stack will overflow, causing the program to crash [(00:52:08)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3128s).
- When a function is called, the argument is also known as the actual argument, and in the called function, the argument is known as the formal argument, with the actual argument being mapped to the formal argument [(00:52:32)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3152s).
- A function call where the value of one variable is copied to another variable is called a call by value, which is what was happening in the example, resulting in the desired result not being achieved [(00:53:17)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3197s).
- To achieve the desired result, pointers can be used as function arguments, allowing the variable local to the main method to be accessed inside the increment function [(00:53:44)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3224s).
- When a pointer to an integer is passed as an argument to a function, it stores the address of an integer, allowing the function to access the variable at that address [(00:54:03)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3243s).
- When the main method calls the increment function, a local variable corresponding to the parameter P is created, which is a pointer to an integer, and the value passed to the function is the address of the variable a [(00:54:46)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3286s).
- The value stored in the variable 'P' is the address of 'A', which is 308, indicating that 'P' is pointing to 'A' [(00:54:58)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3298s).
- When the asterisk symbol is used with 'P', it dereferences the address, allowing access to the value stored at that address [(00:55:11)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3311s).
- The statement '*P = *P + 1' increments the value stored at the address 'P' by one, resulting in 'A' becoming 11 [(00:55:17)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3317s).
- Passing the address of a variable to a function instead of its value is known as call by reference, which allows the function to access and modify the original variable [(00:55:50)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3350s).
- Using pointers as function arguments enables call by reference, which can save memory by avoiding the creation of copies of large and complex data types [(00:56:01)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3361s).
- Call by reference can conserve memory by using a reference to a complex data type instead of creating a new copy, although it still requires a small amount of memory [(00:56:13)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3373s).

## Pointers and arrays [(00:56:36)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3396s)
- When an array is declared, it creates a block of consecutive memory locations to store its elements, with each element having a specific address, and the overall size of the array is the sum of the sizes of its elements [(00:56:51)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3411s).
- In a typical compiler, an integer is stored in four bytes, so the address of each element in an integer array is four bytes ahead of the previous element [(00:57:20)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3440s).
- The memory representation of an array can be shown vertically or horizontally, with the horizontal representation being used to show the memory extending towards the right to accommodate more variables [(00:57:49)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3469s).
- A pointer to an integer can store the address of an integer variable, and [Indirection](https://en.wikipedia.org/wiki/Indirection) the pointer will print the value stored at that address [(00:58:28)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3508s).
- A pointer variable can be incremented or decremented by a constant, which will change the address stored in the pointer, but the value at the new address is unknown unless it is part of an array [(00:59:02)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3542s).
- When a pointer is used to point to the first element of an array, incrementing the pointer will move it to the next element in the array, and dereferencing the pointer will print the value of the next element [(01:00:19)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3619s).
- Using pointer arithmetic makes sense in the case of arrays because the adjacent locations contain known values [(01:00:44)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3644s).
- The name of an array can be used to get a pointer to the first element in the array, allowing statements like "p = a" to be written [(01:00:56)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3656s).
- Printing the variable 'a' in an array gives the address of the first element in the array, while dereferencing it with '*' gives the value of the first element [(01:01:08)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3668s).
- To access the address of an element at index 'i' in the array, either '&a' or 'a + i' can be used, and to access the value, either 'a' or '* (a + i)' can be used [(01:01:44)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3704s).
- The address of the first element in the array can also be referred to as the base address, and using the variable name 'a' gives the base address of the array [(01:02:28)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3748s).
- The expressions '&a' and 'a + i' are equivalent, and the expressions 'a' and '* (a + i)' are also equivalent [(01:02:14)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3734s).
- Simply printing 'a' in an array will give the address of the first element, while printing '&a[(00:00:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=0s)' will give the same address, and printing 'a[(00:00:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=0s)' or '*a' will give the value of the first element [(01:02:51)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3771s).
- Running a loop to print the addresses and values of elements in an array using 'a + i' and '* (a + i)' or '&a' and 'a' will give the expected results [(01:03:42)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3822s).
- Although using the variable name 'a' returns a pointer to the base address, it cannot be incremented like a pointer variable, and assigning 'a' to a pointer variable is necessary to perform pointer arithmetic [(01:04:25)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3865s).
- The next lessons will cover character arrays and passing arrays as function arguments [(01:04:59)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3899s).

## Arrays as function arguments [(01:05:18)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3918s)
- When passing an array as a function argument, the array's size is not explicitly passed, and the function does not know the size of the array [(01:05:26)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=3926s).
- To find the size of the array, the sizeof() function can be used to get the size of the array in bytes, and then divide it by the size of one integer to get the number of elements [(01:06:40)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4000s).
- The size of the array can be calculated in the main method and passed as an argument to the function, or it can be calculated inside the function using the sizeof() function [(01:07:41)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4061s).
- However, when trying to calculate the size of the array inside the function using sizeof(), it does not work as expected because the array decays into a pointer when passed to the function [(01:08:32)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4112s).
- When an array is passed to a function, it decays into a pointer, and the sizeof() function returns the size of the pointer, not the size of the original array [(01:08:51)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4131s).
- This is why calculating the size of the array inside the function using sizeof() does not work, and the function returns an incorrect result [(01:09:04)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4144s).
- To fix this issue, the size of the array should be passed as an argument to the function, or the array should be passed as a reference or a pointer to the first element of the array [(01:07:55)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4075s).
- The correct way to calculate the sum of elements in an array when passing the array as a function argument is to pass the size of the array as an argument and use it to iterate through the array [(01:07:48)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4068s).
- The size of an array 'a' is 20 bytes in the main method, but when passed to the function 'sum of elements', its size is 4 bytes, which is the size of a pointer to an integer, indicating that the array is not copied but a pointer to its first element is passed instead [(01:09:36)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4176s).
- The memory assigned to an application is divided into four parts, and for function calls, the stack section is used, where each function call has its own stack frame containing local variables [(01:10:12)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4212s).
- When the main method is invoked, a stack frame is allocated, and local variables 'a' (the array) and 'total' (an integer) reside within this frame, occupying 20 bytes and 4 bytes respectively [(01:10:38)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4238s).
- When the function 'sum of elements' is called, a new stack frame is allocated, and the value of the local variable 'a' in the main method is not copied, but instead, a pointer to the first element of the array is passed to the function [(01:11:25)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4285s).
- The compiler implicitly converts the array 'a' to a pointer to an integer, so 'int a' is equivalent to 'int *a', and only the address of the first element is copied, not the entire array [(01:13:28)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4408s).
- When an array is passed as a function argument, the compiler creates a pointer variable with the same name, pointing to the data type of the array, and copies the address of the first element, rather than copying the entire array [(01:12:47)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4367s).
- When passing arrays as function arguments, the value of the variable is not copied, but rather the address of the variable is copied and stored, making it a call by reference, which is more memory-efficient, especially for large arrays [(01:14:01)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4441s).
- Arrays are always passed as reference parameters, and this is why the size of an array is not known when it is passed as a function argument, requiring the size to be passed separately [(01:14:27)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4467s).
- When passing an array as a function argument, the compiler interprets it as a pointer to an integer, and the asterisk sign can be used to indicate this, making it clear that the array is being passed as a pointer [(01:14:47)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4487s).
- A variable name used as an array is different from a variable that points to an integer, and while the compiler allows some privileges, such as using the array name to get the pointer to the first element, it is not the same as a pointer variable [(01:15:33)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4533s).
- If a pointer to the starting address of an array is available, it can be used like a variable name for the array, and the array elements can be accessed and modified using the pointer [(01:16:16)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4576s).
- Because arrays are passed by reference, the elements of the array can be modified in the called function, and the changes will be reflected in the calling function [(01:16:39)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4599s).
- An important use case of arrays as function arguments is when working with strings in C, which are essentially character arrays [(01:17:50)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4670s).

## Character arrays and pointers - part 1 [(01:18:10)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4690s)
- Character arrays are used to store strings in C, and strings are groups or sets of characters, such as names, phrases, and sentences, with examples including "john" and other real-world data [(01:18:29)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4709s).
- To store a string in a character array, the array must be large enough to accommodate the string, meaning it should be of size greater than or equal to the number of characters in the string plus one [(01:19:19)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4759s).
- The extra space is needed to store a null character, which has an ASCII value of zero, at the end of the string to indicate its termination, as all string manipulation functions in C expect strings to be null-terminated [(01:21:21)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4881s).
- Without the null character, functions would not know where the string ends, even if the rest of the array is empty, as there would be garbage values in the unused indices [(01:21:04)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4864s).
- A null character is represented as '/0' within single quotes and is used to separate the used and unused parts of the string in the character array [(01:21:39)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4899s).
- The rule for strings in C is that they must be terminated by a null character, which is why an extra space is needed in the character array [(01:21:59)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4919s).
- In [C++](https://en.wikipedia.org/wiki/C++), a null character is used to terminate a string, and it is essential to store this null character when declaring a character array to avoid undefined behavior, especially when using functions like printf that assume the string is null-terminated [(01:22:07)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4927s).
- If a character array is not null-terminated, functions like printf will continue to print characters until a null character is found, resulting in unexpected output [(01:22:31)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4951s).
- Changing the size of the character array to accommodate the null character and adding it explicitly can resolve the issue [(01:22:52)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4972s).
- The printf function will only print characters until it finds a null character, even if the array size is larger [(01:23:04)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=4984s).
- Many functions in the string.h library, such as strlen, assume that the string is null-terminated and will only count characters until a null character is found [(01:23:27)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5007s).
- String literals are groups of characters within double quotation marks and are implicitly null-terminated when stored in memory [(01:24:02)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5042s).
- When declaring and initializing a character array, it must be done in one line, and the size of the array can be omitted, in which case the size will be just enough to store the string plus the null character [(01:24:24)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5064s).
- The size of a character array in bytes can be determined using the sizeof function, which will return the total size, including the null character [(01:24:55)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5095s).
- The length of a string, excluding the null character, can be determined using the strlen function [(01:23:34)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5014s).
- Initializing a character array with a string literal will result in a compilation error if the array size is less than the length of the string plus one for the null character [(01:25:14)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5114s).
- An alternative syntax for initializing a character array is to use a comma-separated list within braces, but this requires explicit null termination and an array size greater than or equal to the number of characters [(01:25:28)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5128s).
- Arrays and pointers are different types in [C++](https://en.wikipedia.org/wiki/C++) but are used in similar ways [(01:25:51)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5151s).
- In C/C++, a string literal is stored in memory as a contiguous block, with each character occupying one byte of memory, and the next character stored at the next memory address [(01:26:08)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5168s).
- A pointer variable, typically stored in four bytes, can be declared to point to a character, and its address can be assigned the address of the first element of a character array [(01:26:38)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5198s).
- When a character array's name is used in an expression, it returns the address of the first element in the array, allowing a pointer variable to be assigned this address [(01:27:03)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5223s).
- A character pointer can be used to read and write into a character array, and modifying the array through the pointer will change the original array [(01:27:38)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5258s).
- The syntax for accessing an array element through a pointer is equivalent to using the array name with an index, with the pointer serving as the base address [(01:27:53)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5273s).
- Unlike arrays, pointers can be modified to point to different elements in an array, and can be incremented or decremented to traverse the array [(01:28:54)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5334s).
- Arrays cannot be reassigned to point to a different location in memory, and cannot be incremented or decremented like pointers [(01:28:42)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5322s).
- When passing arrays to functions, only the base address of the array is passed, not a copy of the entire array, and this is done using a pointer variable [(01:29:41)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5381s).
- Arrays cannot be passed directly to functions due to their large size, so the compiler forces the passing of the array's base address instead, interpreting the array argument as a pointer to the array's first element [(01:30:35)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5435s).
- When passing an array to a function, the function only receives the base address of the array and does not know the array's size, making it necessary to use a null character to determine the end of the array [(01:31:02)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5462s).
- A custom print function can be created to print the string part of a character array by iterating over the array using the base address and printing characters until a null character is encountered [(01:31:13)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5473s).
- The printf function prints garbage values after the end of an array if it is not null-terminated because it continues to access memory locations until it encounters a null character [(01:31:45)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5505s).
- In C, the syntax for printing a character can be either %c or *c, with both being valid and equivalent [(01:32:04)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5524s).
- Instead of using a separate variable to iterate over the array, the array pointer itself can be incremented and used in the loop condition, and this code will also work [(01:32:29)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5549s).

## Character arrays and pointers - part 2 [(01:32:49)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5569s)
- In the context of character arrays and pointers, it's essential to visualize how data is stored in memory, which is typically divided into four parts: code segment, global variables, stack, and heap, with the stack being a contiguous block of memory where local variables are stored [(01:34:02)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5642s).
- When a function is called, a stack frame is allocated for its execution, and local variables are stored within this frame, with the stack increasing from bottom to top [(01:34:53)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5693s).
- In the given example, the main function is allocated a stack frame, and a character array of size 20 is allocated 20 bytes of memory within this frame, with each character stored in one byte [(01:35:19)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5719s).
- When the print function is called, its execution is allocated a new stack frame on top of the main function's stack frame, pausing the main function's execution until the print function finishes [(01:36:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5760s).
- The print function has a local variable 'c', which is a pointer variable taking four bytes of memory in a typical architecture, and is allocated within the print function's stack frame [(01:36:32)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5792s).
- The memory layout should be visualized when writing or executing a program to understand where variables are stored and their scope [(01:34:26)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5666s).
- A string literal is used in the example, which implies null termination, and the string is stored in a character array with a size of 20, but only five characters are used [(01:33:43)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5623s).
- The program's execution starts with the main function, which invokes the print function, and the stack frames are allocated accordingly [(01:34:46)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5686s).
- In the context of C programming, the variable 'c' in 'main' and 'c' in 'print' are different due to having different scopes, even if they have the same name. [(01:36:50)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5810s)
- When 'c' is passed to the 'print' function, the base address of the array (100) is passed and stored in a pointer variable within 'print'. [(01:37:10)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5830s)
- The 'print' function has its own local variable 'c', which is a character pointer that stores the address 100, pointing to the first element of the array. [(01:38:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5880s)
- The asterisk operator (*) is used to access the value at the address stored in a pointer variable, so '*c' would give the value at the address pointed to by 'c'. [(01:38:32)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5912s)
- In pointer arithmetic, incrementing a pointer by one unit increments the address by the size of the data type it points to, so for a character pointer, 'c++' would increment the address by one byte. [(01:39:08)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5948s)
- The 'while' loop in 'print' continues to execute as long as '*c' is not equal to the null character, printing each character in the array and incrementing 'c' to point to the next character. [(01:38:32)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=5912s)
- Once the loop finishes, the stack frame for 'print' is cleared, and 'main' resumes execution. [(01:40:02)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6002s)
- Modifying the code to use a character pointer 'c' initialized with a string literal results in the same output, with the string being stored in memory and 'c' pointing to the first character. [(01:40:29)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6029s)
- When using a character array in [C++](https://en.wikipedia.org/wiki/C++), the string is stored on the stack, but if a string literal is used elsewhere in a statement or passed to a function, it is stored as a constant during compile time, most likely in the text segment of the application memory, and cannot be modified [(01:41:02)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6062s).
- If a character array is passed to a function, the function receives it in a character pointer, allowing the data in the array to be modified using the pointer [(01:41:48)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6108s).
- To prevent modification of the data in the array, the function argument can be changed to a const character pointer, allowing the function to read the string but not write to it [(01:42:17)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6137s).
- Using const character pointers can help prevent bugs by forcing read-only behavior when necessary [(01:42:25)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6145s).
- Pointers can be tricky to work with, even for experienced programmers, and writing code is the best way to learn and understand how to use them effectively [(01:42:43)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6163s).

## Pointers and 2-D arrays [(01:42:49)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6169s)
- Pointers and arrays are closely related concepts, and understanding how multi-dimensional arrays are organized in computer memory is crucial for working with them using pointers [(01:42:54)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6174s).
- A one-dimensional array is stored in a contiguous block of memory, with each element having a unique address, and the starting address of the array can be used to access its elements [(01:43:34)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6214s).
- When declaring a one-dimensional array, a contiguous block of memory is created, and each element can be accessed using its index or by using pointer arithmetic and [Indirection](https://en.wikipedia.org/wiki/Indirection) [(01:43:40)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6220s).
- The name of the array can be used as a pointer to the first element of the array, and pointer arithmetic and dereferencing can be used to access all elements in the array [(01:44:43)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6283s).
- The address stored in a pointer can be printed, and dereferencing the pointer will give the value of the element at that address [(01:45:09)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6309s).
- Pointer arithmetic can be used to access elements in the array, and adding one to an [Const (computer programming)](https://en.wikipedia.org/wiki/Const_(computer_programming)) will take us to the address of the next integer, which is four bytes ahead [(01:45:21)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6321s).
- The name of the array can be used instead of a pointer for dereferencing and arithmetic, and [Asterix](https://en.wikipedia.org/wiki/Asterix) a plus i is the same as AI, which gives the address of the ith element in the array [(01:46:11)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6371s).
- Although the name of the array can be used like a pointer, it is not seen as a pointer variable, and assigning a pointer to an array is allowed, but assigning an array to a pointer is not [(01:46:33)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6393s).
- Understanding how to use pointers with one-dimensional arrays is essential before moving on to working with multi-dimensional arrays [(01:46:51)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6411s).
- A two-dimensional array of integers named 't' is declared, creating an array of arrays, with 'b0' and 'b1' being one-dimensional arrays of three integers each, where each integer is four bytes in size [(01:47:04)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6424s).
- The memory layout of the array is described, with 'b0' occupying the first 12 bytes starting at address 400, and 'b1' occupying the next 12 bytes starting at address 412 [(01:47:33)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6453s).
- The name of the array 't' returns a pointer to the first element, which is a one-dimensional array of three integers, and the type of the pointer matters when [Indirection](https://en.wikipedia.org/wiki/Indirection) or performing pointer arithmetic [(01:47:53)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6473s).
- A pointer to a one-dimensional array of three integers is defined and equated with 't', allowing for correct pointer arithmetic and dereferencing [(01:48:33)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6513s).
- Printing the address of 'b0' using the pointer 'p' returns the address 400, and printing the value of 'b0' using the pointer 'p' returns the first integer in 'b0' [(01:48:42)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6522s).
- The address of each block of four bytes in the 2D array is described, with the address of a block being the address of the first byte in the block [(01:49:42)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6582s).
- The value of 't + 1' is calculated, which returns the address 412, because 't' is a pointer to a one-dimensional array of three integers, and adding 1 moves to the next array [(01:50:01)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6601s).
- The value of '*t + 1' is calculated, which returns the entire one-dimensional array of three integers starting at address 412, because the type of the pointer 't' is important when dereferencing [(01:50:37)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6637s).
- Printing '*t + 1' returns the same value as 'b1', which is the pointer to the first integer in 'b1', and the output is the address 412 [(01:50:59)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6659s).
- The expressions '*p + 1', 'b1', and '&v1[(00:00:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=0s)' all return a pointer to an integer [(01:51:21)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6681s).
- The expression [Asterix](6de45902-db6f-433e-a73a-192aa95985a9) B + 1 + 2 involves pointer arithmetic, where Asterix B + 1 returns an [Const (computer programming)](https://en.wikipedia.org/wiki/Const_(computer_programming)) to the first integer and adding 2 skips 8 bytes, referencing the integer at address 420, equivalent to B[(00:00:12)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12s) or &B[(00:00:12)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12s) [(01:51:36)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6696s).
- The expression Asterix B + 1 can be written as B, and adding 2 returns a pointer to the integer at address 420 [(01:51:42)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6702s).
- The expression Asterix Asterix B + 1 involves [Indirection](https://en.wikipedia.org/wiki/Indirection) a pointer to a one-dimensional array, where B returns a pointer to a one-dimensional array of size 3, and dereferencing it gives the one-dimensional array, equivalent to B[(00:00:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=0s) or &B[(00:00:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=0s)[(00:00:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=0s) [6771.84].
- Adding 1 to an integer pointer takes it 4 bytes ahead to the next integer, returning a pointer to the next integer, so Asterix B + 1 returns a pointer to the integer at address 404, equivalent to &B[(00:00:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=0s)[(00:00:01)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1s) [(01:53:43)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6823s).
- The expression Asterix Asterix B + 1 can be simplified to B[(00:00:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=0s)[(00:00:01)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1s) or *(B + 0) + 1 or *(B[(00:00:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=0s) + 1) [(01:54:10)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6850s).
- A two-dimensional array B[j] can be written as Asterix of B + i + j or *(B + i) + j or *(B + j) [(01:54:19)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6859s).
- The discussion has been about working with two-dimensional arrays using pointers, and future lessons will cover working with higher-dimensional arrays and passing arrays to functions through pointers [(01:54:50)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6890s).

## Pointers and multidimensional arrays [(01:55:07)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6907s)
- A multi-dimensional array can be thought of as an array of arrays, where each array is a collection of similar objects, and this concept is crucial when working with pointers in [C++](https://en.wikipedia.org/wiki/C++). [(01:55:40)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6940s)
- When a multi-dimensional array is created, it is organized in memory as a contiguous block, with each element having a specific address, and this organization is essential for understanding how pointers work with these arrays. [(01:56:18)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=6978s)
- In a two-dimensional array, each row can be considered a one-dimensional array, and the array name returns a pointer to the first element of the array, which is a pointer to a one-dimensional array of a specific size. [(01:58:26)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7106s)
- When declaring a pointer to a multi-dimensional array, the pointer type should match the type of the array, for example, a pointer to a one-dimensional array of three integers, and this is essential for correct pointer arithmetic and array access. [(01:58:48)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7128s)
- A pointer to a two-dimensional array will return a pointer to a one-dimensional array of a specific size, not a pointer to an integer, and this distinction is crucial when working with pointers and multi-dimensional arrays. [(01:58:59)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7139s)
- In C/C++, when using the array name B, it returns a pointer to the first one-dimensional array in B, and the type of a pointer variable is relevant only when trying to dereference or perform pointer arithmetic [(01:59:30)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7170s).
- When printing the address stored in a pointer variable, it will be the starting address of the first byte of a block of memory, regardless of the type of pointer [(01:59:49)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7189s).
- Using [Asterix](https://en.wikipedia.org/wiki/Asterix) B (or B[(00:00:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=0s)) returns a pointer to the first integer in B[(00:00:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=0s), while using B returns a pointer to a one-dimensional array of three integers [(02:00:20)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7220s).
- The difference between B and Asterix B is the type of pointer returned, but when printing the address, both will return the same starting address [(02:00:43)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7243s).
- The type of pointer plays a role when trying to dereference or perform pointer arithmetic, but not when printing the address [(02:01:06)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7266s).
- B[j] can be written as Asterix of B + j, where B returns an [Const (computer programming)](https://en.wikipedia.org/wiki/Const_(computer_programming)) to the first integer in the one-dimensional array B [7277.52].
- B can also be written as Asterix B + i, where B is a pointer to a one-dimensional array of three integers, and B + i returns a pointer to a one-dimensional array of three integers [(02:01:47)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7307s).
- Understanding pointer arithmetic and [Indirection](https://en.wikipedia.org/wiki/Indirection) in two-dimensional arrays is essential to understanding how it works in three-dimensional arrays [(02:02:18)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7338s).
- A three-dimensional array is an array of two-dimensional arrays, and each two-dimensional array can be further broken down into one-dimensional arrays [(02:02:39)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7359s).
- In memory, a three-dimensional array C can be represented as a collection of two-dimensional arrays, each with its own starting address [(02:02:46)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7366s).
- In C, a two-dimensional array can be accessed using pointers, where the array name itself acts as a pointer to a two-dimensional array of integers of a specified size, such as in the example array C, which is a 2x2 array of integers [(02:03:52)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7432s).
- When printing the array name C, the output will be the memory address of the array, which is 800, and performing a dereferencing operation on C will return a pointer to the first element in the first row of the array, C[(00:00:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=0s), which is also a one-dimensional array of integers [(02:04:21)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7461s).
- The expressions [Asterix](https://en.wikipedia.org/wiki/Asterix) C, Asterix C[(00:00:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=0s), and Asterix C[(00:00:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=0s)[(00:00:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=0s) all return pointers to different levels of the array, with Asterix C returning a pointer to a two-dimensional array, Asterix C[(00:00:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=0s) returning a pointer to a one-dimensional array, and Asterix C[(00:00:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=0s)[(00:00:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=0s) returning a pointer to an integer [(02:04:37)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7477s).
- The expression C[j][k] can be written as Asterix of C[j] + k, which can be further simplified to Asterix of Asterix of C + j + k, demonstrating how to access elements in a multi-dimensional array using pointers [(02:05:15)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7515s).
- Understanding pointer arithmetic and [Indirection](https://en.wikipedia.org/wiki/Indirection) is crucial for working with multi-dimensional arrays using pointers [(02:05:48)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7548s).
- The expression C[(00:00:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=0s)[(00:00:01)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1s) can be simplified to Asterix of C[(00:00:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=0s) + 1, which returns a pointer to the second element in the first row of the array, and dereferencing this expression will return the value of the second element, which is 9 [(02:06:11)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7571s).
- The expression Asterix of C[(00:00:01)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=1s) + 1 returns a pointer to the second one-dimensional array in the second row of the array, and dereferencing this expression will return a pointer to the first element in this array, which is the integer 6 [(02:06:41)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7601s).
- The memory addresses of the elements in the array can be calculated manually, with each integer taking up 4 bytes of memory, and the addresses can be verified by running a C program that prints the addresses of the elements [(02:07:40)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7660s).
- The output of a printf statement can vary between different runs of a program due to the assigned address changing each time, but the address will remain the same for multiple expressions within the same run [(02:08:15)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7695s).
- When passing a one-dimensional array as a function argument, the syntax used is syntactical sugar and is interpreted by the compiler as a pointer to the array, not a fresh copy of the array [(02:09:12)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7752s).
- To pass a one-dimensional array to a function, the function argument can be declared as a pointer to the array type, and the array can be passed to the function without the need for the & operator [(02:09:33)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7773s).
- When passing a two-dimensional array to a function, the function argument must be declared as a pointer to an array of arrays, with the inner array size specified, and only the first dimension can be left empty [(02:10:16)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7816s).
- A two-dimensional array with a different inner array size than the function expects cannot be passed to the function, but a two-dimensional array with a compatible inner array size can be passed [(02:10:53)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7853s).
- To pass a three-dimensional array to a function, the function argument must be declared as a pointer to a two-dimensional array, with the inner array sizes specified, and the three-dimensional array can be passed to the function [(02:11:11)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7871s).
- When passing multi-dimensional arrays to functions, except for the first dimension, all other dimensions must be specified, and using a pointer to a pointer or other incorrect syntax will not work [(02:11:40)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7900s).

## Pointers and dynamic memory - stack vs heap [(02:11:50)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7910s)
- Memory is a crucial resource on a machine, and understanding its architecture and management is essential for programmers [(02:11:59)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7919s).
- The memory assigned to a program can be divided into four segments: one for storing instructions, another for static or global variables, one for storing information of function calls and local variables (the stack), and the fourth segment (the heap) [(02:12:28)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7948s).
- The amount of memory set aside for the text segment, global variable segment, and the stack does not grow while the application is running [(02:13:22)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8002s).
- When a program executes, memory from the stack is allocated for the execution of each function, and this allocated memory is called the stack frame for that method [(02:14:26)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8066s).
- The size of the stack frame for a method is calculated when the program is compiling, and it stores local variables, arguments, and information about where the function should return to [(02:14:40)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8080s).
- At any time during the execution of the program, the function at the top of the stack is executing, while the rest are paused, waiting for the function above to return something and then resuming execution [(02:15:31)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8131s).
- Global variables, which are not declared inside a function, are stored in the global variable segment of memory and can be accessed anywhere during the application's lifecycle [(02:15:52)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8152s).
- Local variables, which are declared inside a function, are stored in the stack frame of that function and only live until the function is executing [(02:13:09)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=7989s).
- A program's call stack contains the methods currently being executed, and when a method finishes, it is cleared from the stack memory, allowing the previous method to resume execution [(02:16:07)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8167s).
- Global variables are stored separately and remain in memory until the program finishes, so they should only be used when necessary to avoid wasting memory [(02:17:06)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8226s).
- When a program starts, the operating system allocates a reserved space for the stack, and the actual allocation of local variables happens during runtime [(02:17:38)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8258s).
- If the call stack grows beyond the reserved memory, it can cause a Stack Overflow, which can occur when a program has infinite recursion or excessive method calls [(02:18:11)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8291s).
- The stack has limitations, including a fixed memory size that does not grow during runtime, and applications cannot request more memory for the stack [(02:18:31)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8311s).
- Memory allocation and deallocation on the stack follow a set rule, where functions are pushed onto the stack when called and popped when finished, and variable scope cannot be manipulated [(02:18:52)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8332s).
- The stack has limitations for large data types, such as arrays, which must have a fixed size known at compile time [(02:19:10)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8350s).
- The heap is a memory space that can vary in size during the application's lifetime, and there is no set rule for allocation and deallocation, allowing programs to control memory usage [(02:19:38)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8378s).
- The heap can grow as long as the system has available memory, but this requires careful management to avoid running out of memory [(02:20:07)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8407s).
- The heap is a large free pool of memory that can be used flexibly as per the programmer's need, and it is also referred to as dynamic memory or free pool of memory, from which as much memory as needed can be allocated [(02:20:19)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8419s).
- The heap is implemented by the operating system, Language Runtime, or the compiler, and its implementation can vary depending on the computer architecture [(02:20:26)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8426s).
- The term "heap" in this context has nothing to do with the heap data structure, and it is only used to refer to the large free pool of memory [(02:21:24)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8484s).
- To use dynamic memory in C, four functions are needed: malloc, calloc, realloc, and free, while in [C++](https://en.wikipedia.org/wiki/C++), two operators are used: new and delete [(02:21:59)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8519s).
- Dynamic memory allocation allows for the allocation of memory on the heap, which can be used to store variables, and this memory is not allocated on the stack [(02:22:37)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8557s).
- When a variable is declared, it is a local variable and is allocated on the stack, but when memory is allocated on the heap using malloc, a block of memory is reserved on the heap and a pointer to the starting address of this block is returned [(02:23:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8580s).
- The malloc function returns a void pointer, which needs to be typecasted to the correct pointer type, and it returns the starting address of the allocated block of memory [(02:23:45)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8625s).
- The allocated memory on the heap can be used to store variables, but initially, the contents of this memory are unknown, and they need to be filled in by the programmer [(02:24:23)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8663s).
- To use memory on the heap, it must be accessed through a reference, and the only way to access a particular block of memory is by keeping a pointer variable local to the function [(02:24:36)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8676s).
- When malloc is called, it looks for free space in the heap, reserves a block of memory, and returns a pointer to that block, allowing the programmer to access and modify the memory [(02:24:41)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8681s).
- If malloc is called again, a new block of memory is allocated on the heap, and the returned address can be stored in a pointer variable, allowing the programmer to access and modify the new block of memory [(02:25:07)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8707s).
- The previous block of memory allocated on the heap is not automatically cleared, and it is the programmer's responsibility to clear it using the free function when it is no longer needed [(02:25:40)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8740s).
- To clear a block of memory allocated using malloc, the free function is called, passing the pointer to the starting address of the memory block [(02:26:08)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8768s).
- Memory allocated on the heap is not automatically deallocated when a function completes, unlike memory allocated on the stack, and it does not need to live for the whole lifetime of the application, like a global variable [(02:26:37)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8797s).
- To store an array on the heap, a call to malloc is made, asking for a block of memory equal to the total size of the array in bytes, and the returned address can be used as the base address of the array [(02:26:58)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8818s).
- If malloc is unable to find a free block of memory, it returns a null pointer, and error handling code should be written to handle this case [(02:28:01)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8881s).
- In [C++](https://en.wikipedia.org/wiki/C++), the new and delete operators are used instead of malloc and free to allocate and deallocate memory on the heap [(02:28:25)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8905s).
- In C++, the new operator is used instead of malloc to allocate memory, and delete is used instead of free to deallocate memory [(02:28:32)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8912s).
- To allocate an array in C++, the size is specified in brackets after the new operator [(02:28:37)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8917s).
- To deallocate an array in C++, the delete operator is used with one bracket [(02:28:50)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8930s).
- Unlike malloc, the new and delete operators in C++ are type-safe, meaning they are used with a specific type and return pointers to that type only [(02:28:55)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8935s).
- The new operator returns a pointer to a specific type, eliminating the need for typecasting, as seen with malloc which returns a void type [(02:29:01)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8941s).
- The new and delete operators will be discussed further in the context of dynamic memory allocation and other library functions [(02:29:12)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8952s).

## Dynamic memory allocation in C - malloc calloc realloc free [(02:29:14)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8954s)
- The concept of dynamic memory allocation was previously discussed, including the stack and heap in the context of an application's memory, and this lesson will explore library functions available in C for dynamic memory allocation, specifically malloc, calloc, realloc, and free [(02:29:18)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=8958s).
- The malloc function is the most frequently used library function for dynamic memory allocation, and its signature asks for the size of the memory block in bytes, using the size_t data type, which stores positive integer values [(02:30:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9000s).
- The malloc function returns a void pointer that gives the address of the first byte in the block of memory it allocates, and the size of the memory block cannot be a negative value, zero, or a positive value [(02:30:48)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9048s).
- When using malloc, the address returned by the function is typically stored in a void pointer variable, and the address can be printed to show the starting address of the allocated memory block [(02:31:46)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9106s).
- In practice, the amount of memory needed is typically calculated before allocating memory, using the sizeof function to determine the size of a variable in bytes, and then multiplying this value by the number of units needed [(02:32:27)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9147s).
- The sizeof function returns the size of a variable in bytes, and this value is often multiplied by the number of units needed to determine the total amount of memory required, such as allocating memory for 10 integers [(02:32:47)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9167s).
- The size of a data type, such as an integer, can be known in advance, and this value can be used to allocate memory, but using the sizeof function is a more general and flexible approach [(02:33:12)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9192s).
- The size of a variable depends on the compiler, and when using malloc to allocate memory for complex data types, the total number of bytes should be calculated as the number of elements multiplied by the size of one unit of the data type [(02:33:23)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9203s).
- malloc returns a void pointer, which cannot be dereferenced directly and must be typecasted into a pointer type of a particular data type before use [(02:34:08)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9248s).
- To use a block of memory allocated by malloc, the void pointer must be typecasted into a pointer of the desired data type, such as a pointer to an integer [(02:34:47)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9287s).
- Once typecasted, the pointer can be used to assign values to specific elements in the allocated memory block by [Indirection](https://en.wikipedia.org/wiki/Indirection) the address and incrementing the pointer to access subsequent elements [(02:35:12)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9312s).
- Dynamically allocated memory is manipulated through pointers, where the pointer is incremented to access the next element in the array [(02:35:56)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9356s).
- The calloc function is similar to malloc but takes two arguments: the number of elements of a particular data type and the size of the data type [(02:36:15)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9375s).
- calloc also returns a void pointer and is used to allocate a block of memory for an array of a specific size and data type [(02:36:20)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9380s).

## Pointers as function returns in C/C [(02:36:48)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9408s)
- The calloc function is used to allocate memory and initialize all bytes to zero, taking two arguments: the number of elements and the size of the data type in bytes [(02:36:50)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9410s).
- Unlike malloc, calloc initializes the allocated memory to zero, while malloc does not initialize the memory and may contain garbage values [(02:37:07)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9427s).
- The realloc function is used to change the size of a dynamically allocated block of memory, taking two arguments: the starting address of the existing block and the size of the new block [(02:37:43)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9463s).
- realloc may create a new block and copy the previous data if the new size is larger, or extend the existing block if contiguous memory is available [(02:38:09)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9489s).
- Dynamic memory allocation can be used to declare arrays with a size determined by user input, which is not possible with static arrays [(02:38:52)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9532s).
- To allocate memory dynamically, the malloc function is used with a typecast to the desired data type, such as int* [(02:39:35)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9575s).
- The allocated memory can be used to store data, and the elements can be accessed and printed like a regular array [(02:39:50)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9590s).
- Using calloc instead of malloc would require two arguments and would initialize the allocated memory to zero [(02:40:36)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9636s).
- The main difference between malloc and calloc is that calloc initializes the allocated memory to zero, while malloc does not, resulting in garbage values in the allocated memory [(02:40:56)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9656s).
- Dynamically allocated memory remains allocated until the program's lifetime, unless explicitly deallocated using the free function, which takes the starting address of the memory block as an argument [(02:41:29)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9689s).
- After freeing a memory block, the data in that memory may or may not be erased, depending on the compiler or machine, but the memory becomes available for allocation against another call to malloc [(02:41:53)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9713s).
- Even after freeing a memory block, it is still possible to access the value at that memory location using a pointer, but this is a dangerous practice and can lead to unpredictable behavior [(02:42:29)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9749s).
- If a memory block is not allocated to the program, reading or writing to that address can have unpredictable consequences, and may cause the program to crash [(02:42:50)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9770s).
- Modifying the size of a memory block can be done using the realloc function, which creates a new memory block of the specified size, copies the values from the previous block, and deallocates the previous block [(02:43:35)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9815s).
- The realloc function attempts to extend the previous block if possible, but if not, it allocates a new block and copies the values, and the previous block is deallocated [(02:44:16)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9856s).
- When using the realloc function, a new block is allocated, and the content from the previous block is copied to the new block, then the previous block is deallocated, unless it is possible to extend the previous block, in which case the same block is used [(02:44:42)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9882s).
- If the new size is smaller than the original size, the previous block is reduced, and the excess space is deallocated [(02:45:24)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9924s).
- If the new size is set to zero, the complete block is deallocated, which is equivalent to using the free function [(02:45:50)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9950s).
- In most cases, the return address from realloc is stored in the same [Const (computer programming)](https://en.wikipedia.org/wiki/Const_(computer_programming)), so instead of using a new pointer, the original pointer can be used [(02:46:03)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9963s).
- If the first argument to realloc is null, and the second argument is the size, it is equivalent to calling malloc, which creates a new block without copying anything from the previous block [(02:46:15)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9975s).
- Realloc can be used as a substitute for both free and malloc with the right arguments [(02:46:36)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=9996s).
- A function can return a pointer, which is just another data type that stores the address of another data type [(02:46:59)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=10019s).
- When a function returns a value, the value from the local variable in the function is copied to the variable in the main function, and the local variables in the function are deallocated [(02:48:20)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=10100s).
- Local variables in a function are not accessible outside the function, and local variables in the main function are not accessible inside the function, unless their values are passed as arguments or returned as values [(02:48:36)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=10116s).
- When passing variables to a function, the values are copied to the function's local variables, and the original variables in the calling function remain unchanged, as demonstrated by printing the addresses of variables 'a' in 'Maine' and 'AD' which are different ([(02:49:13)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=10153s)).
- The process of passing variables to a function by copying their values is called "call by value" or "pass by value" ([(02:49:54)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=10194s)).
- To pass variables to a function by reference, the addresses of the variables are passed instead of their values, and the function receives these addresses as pointer variables ([(02:50:08)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=10208s)).
- In a function call by reference, the variables in the called function are pointer variables that store the addresses of the original variables in the calling function, and the asterisk operator is used to access the values at these addresses ([(02:50:35)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=10235s)).
- The variables in the called function, whether they are integers or pointers, are local to the function and have different types than the original variables in the calling function ([(02:50:56)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=10256s)).
- To return a value from a function by reference, the address of a variable in the called function can be returned, and the calling function can collect this address using a pointer variable ([(02:52:28)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=10348s)).
- The ampersand operator is used to get the address of a variable, and the asterisk operator is used to access the value at an address ([(02:51:40)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=10300s)).
- The add function has been modified to return a pointer to an integer, and there are two valid syntaxes for declaring this: int *add or int* add [(02:53:03)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=10383s).
- The function print_hello_world has been added, which simply prints "hello world," and it is called before printing the sum, resulting in an incorrect output [(02:53:58)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=10438s).
- The memory allocated to a program is typically divided into sections, including the stack, where local variables and function call information are stored [(02:54:24)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=10464s).
- When a function is called, a stack frame is allocated for its execution, and local variables live inside this stack frame [(02:54:48)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=10488s).
- The main function has a stack frame with local variables a, b, and ptr, and when the add function is called, its execution pauses, and memory is allocated for the add function [(02:55:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=10500s).
- The add function has local variables a, b, and c, and it calculates the sum of a and b and returns the address of its local variable c [(02:56:04)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=10564s).
- After the add function finishes its execution, the memory allocated to it is deallocated, and the memory above address 130 can be used for other function calls [(02:57:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=10620s).
- The variable ptr stores the address 144, which is the address of the local variable c in the add function, even though the memory allocated to the add function has been deallocated [(02:57:16)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=10636s).

## Function Pointers in C / C [(03:02:01)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=10921s)
- Function pointers are used to store the address of functions, and they can be used to dereference and execute the function, which is an interesting concept [(03:02:13)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=10933s).
- Pointers are data types that can store the address of data stored in a computer's memory, and they can point to variables or constants [(03:02:25)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=10945s).
- Pointers can be used not just to store addresses, but also to dereference and get the value at the address they are pointing to [(03:02:43)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=10963s).
- The address of a function is stored in the memory allocated to an application or program, which can be divided into four segments: code or text segment, data segment, heap segment, and stack segment [(03:03:26)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11006s).
- A program is a set of instructions that are encoded in binary and executed by the computer, and it is written in a high-level language like C or [C++](https://en.wikipedia.org/wiki/C++) and then compiled into machine code or executable code [(03:03:43)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11023s).
- The compiler takes one or more source files as input and generates an executable file that contains the machine code, which is stored in a disk drive or secondary storage device [(03:04:18)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11058s).
- When a program starts execution, a chunk of main memory or [Random-access memory](https://en.wikipedia.org/wiki/Random-access_memory) is allocated to it, and this memory is claimed back when the application finishes execution [(03:05:09)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11109s).
- The code or text segment of an application's memory contains the machine code or instructions copied from the executable file, which are executed by the computer [(03:05:47)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11147s).
- In machine language, each instruction takes a fixed amount of bytes, and instructions are stored in contiguous blocks of memory with increasing addresses, with each instruction executed sequentially unless a jump instruction is encountered [(03:06:20)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11180s).
- A function is a set of instructions stored in a contiguous block of memory, and its address, also known as the entry point, is the address of the first instruction in the function [(03:07:28)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11248s).
- A function call in machine language is an instruction to jump to the entry point of a function, and function pointers store the starting address or entry point of the block of memory containing all the instructions in a function [(03:08:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11280s).
- To create a function pointer in C or [C++](https://en.wikipedia.org/wiki/C++), the syntax is to specify the return type of the function, followed by an asterisk and the name of the variable, and then the argument types of the function in parentheses [(03:08:59)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11339s).
- The argument types in the function pointer declaration should match the argument types of the function it points to, and the function pointer can be initialized with the address of a function using the ampersand operator [(03:09:33)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11373s).
- A function pointer can be used to execute the function it points to by [Indirection](https://en.wikipedia.org/wiki/Indirection) the pointer using the asterisk operator and passing the required arguments [(03:10:05)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11405s).
- The address of a function can be obtained using the ampersand operator, and this address can be assigned to a function pointer, allowing the function to be executed using the pointer [(03:09:50)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11390s).
- Function pointers can be used to store the address of a function and execute it later, and they are commonly used in C and C++ programming for tasks such as callback functions and function tables [(03:08:35)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11315s).
- Function pointers can be used to refer to a function and execute it, as demonstrated by the example where a function pointer is used to add two integers and print the result, which is five [(03:10:33)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11433s).
- The syntax of function pointer declaration requires the identifier or name of the pointer to be within parentheses to avoid confusion with a function that returns a pointer to an integer [(03:10:50)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11450s).
- If the parentheses are not used, the declaration would mean a function that returns a pointer to an integer, as shown in the example where the declaration is written without parentheses [(03:11:09)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11469s).
- The [Asterix](https://en.wikipedia.org/wiki/Asterix) can be placed before the function name or after the return type, and both syntaxes are the same, but using parentheses is necessary to declare a function pointer [(03:11:21)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11481s).
- In the initialization of a function pointer, the ampersand operator is used, but it is not necessary, and using the function name alone will also return the address of the function [(03:11:36)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11496s).
- Function pointers can be used with or without the parentheses and Asterix operator, and both methods are acceptable, as demonstrated by the example where the function pointer name is used alone [(03:11:57)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11517s).
- There are two possible syntaxes for referencing and [Indirection](https://en.wikipedia.org/wiki/Indirection) function pointers, and either one can be used [(03:12:15)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11535s).
- The type of the function pointer must match the type of the function it points to, and if the types do not match, a compilation error will occur [(03:12:28)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11548s).
- Function pointers can be used to point to functions with different signatures, as demonstrated by the examples where function pointers are used to point to functions that take different numbers and types of arguments [(03:12:58)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11578s).
- Function pointers can be used to execute functions that take arguments, as demonstrated by the example where a function pointer is used to execute a function that takes a string as an argument [(03:13:37)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11617s).

## Function pointers and callbacks [(03:13:57)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11637s)
- Function pointers can be passed as arguments to functions, and the receiving function can call back the function that the pointer points to, which is a key concept in understanding the use cases of function pointers [(03:14:33)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11673s).
- A simple example demonstrates this concept by creating a function "a" that prints "Hello" and a function "b" that takes a function pointer as an argument and calls the function it points to, showing that function "a" can be executed through a callback [(03:14:52)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11692s).
- In the example, a function pointer "p" is declared and initialized with the address of function "a", and then passed to function "b", which calls function "a" through the function pointer, resulting in "Hello" being printed on the screen [(03:15:36)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11736s).
- The name of a function returns a pointer, so a single statement can be used to declare and initialize a function pointer, making the code more concise [(03:16:09)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11769s).
- When a reference to a function is passed to another function, the particular function is called a callback function, and in this case, function "a" is a callback function that can be called back by function "b" through the function pointer [(03:16:25)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11785s).
- A more meaningful example demonstrates the use of function pointers and callbacks by sorting a list of integers in an array using a custom sort function that takes an array and the number of elements as arguments [(03:16:57)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11817s).
- The custom sort function, named "bubble_sort", uses the [Bubble sort](https://en.wikipedia.org/wiki/Bubble_sort) algorithm to sort the array in increasing order, making multiple passes on the array and comparing adjacent elements to swap them if necessary [(03:17:18)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11838s).
- The bubble sort algorithm makes "n" passes on the array, and after the first pass, the largest element in the list bubbles up to the highest index [(03:18:05)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11885s).
- Bubble sort is a sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order, and this process continues until the entire list is sorted, which takes n passes for a list of n elements [(03:18:19)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11899s).
- To sort a list in decreasing order, the comparison logic in the if statement needs to be changed to push the largest element towards higher indices [(03:18:57)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11937s).
- By changing the comparison logic, the list can be sorted in either increasing or decreasing order, and the output will be as expected [(03:19:30)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=11970s).
- To avoid writing duplicate code for sorting in increasing and decreasing order, a flag can be passed to the sort function to determine the order, or a function pointer can be used to decide the comparison logic [(03:20:24)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12024s).
- Using a function pointer allows the sort function to take a callback function as an argument, which compares two integers and returns an integer indicating their rank [(03:21:21)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12081s).
- The callback function should take two integers as arguments, compare them, and return 1 if the first element has a higher rank, 0 if they are equal, and -1 if the second element has a higher rank [(03:21:33)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12093s).
- The sort function will use the callback function for comparison and sort the list based on the ranking mechanism defined by the callback function [(03:22:06)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12126s).
- A callback function is used as an argument to the bubblesort function, allowing for different comparison logic to be implemented, such as sorting in increasing or decreasing order, or by absolute value [(03:22:13)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12133s).
- The comparison function determines the ranking mechanism, and by changing the comparison logic, the sorting order can be modified, for example, by returning minus one if a is greater than b to sort in decreasing order [(03:23:12)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12192s).
- The bubblesort function can be made generic by using a callback function, allowing it to sort a list of integers based on any ranking mechanism, and a separate comparison function can be written for each ranking mechanism [(03:23:36)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12216s).
- To sort an array of integers with both positive and negative values by absolute value, a new comparison function named absolute compare can be written, which uses the abs function from the math library to compare the absolute values of the integers [(03:24:28)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12268s).
- The absolute compare function is then passed to the bubblesort function to sort the array by absolute value, demonstrating the flexibility of the callback function approach [(03:25:04)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12304s).
- The qsort function from the stdlib library is a more generic sorting function that can take any array, including arrays of integers, characters, or complex data types, and requires a function pointer to a comparison function as an argument [(03:25:34)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12334s).
- The comparison function for qsort should have a specific signature, taking two constant void pointers as arguments, and the size of the data type in bytes should be passed as an argument to qsort [(03:26:14)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12374s).
- A comparison function for Q sort is written, which takes two void pointers as arguments and returns an integer, allowing it to be used with any data type by typecasting the void pointers to the desired type [(03:26:29)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12389s).
- The comparison function is used to rank elements, returning a positive integer if the first element is ranked higher, a negative integer if the second element is ranked higher, and zero if both elements are ranked the same [(03:27:15)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12435s).
- To get the values of the elements, the void pointers are typecast to int pointers and then dereferenced using the [Asterix](https://en.wikipedia.org/wiki/Asterix) operator [(03:27:02)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12422s).
- The comparison function can be used to sort an array in increasing or decreasing order by changing the return statement to A minus B or B minus A, respectively [(03:28:10)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12490s).
- The comparison function can also be used to sort an array based on the absolute values of the elements by returning the absolute value of A minus the absolute value of B [(03:28:22)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12502s).
- The const keyword is used in the comparison function to indicate that the addresses passed through the pointers cannot be modified [(03:28:35)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12515s).
- Void pointers are used in the Q sort function due to its generic design, allowing it to sort arrays of any data type [(03:28:43)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12523s).
- The concept of callback, as demonstrated by the use of function pointers in Q sort, is also used in event handling and other design scenarios [(03:29:03)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12543s).

## Memory leak in C/C [(03:29:16)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12556s)
- The concept of dynamic memory allocation and the difference between stack and heap in an application's memory have been previously discussed, and now the focus is on memory leaks caused by improper use of dynamic memory or the heap [(03:29:28)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12568s).
- An application's memory is typically divided into four segments: the code segment (or text segment) for storing program instructions, the global variable segment for storing global variables, the stack segment for executing function calls and storing local variables, and the heap (or dynamic memory) segment which can grow as needed [(03:29:57)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12597s).
- The size of the code segment, global variable segment, and stack segment are fixed and decided at compile time, whereas the heap does not have a fixed size and can grow as needed [(03:30:34)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12634s).
- Memory is allocated from the heap using the malloc function in C, and deallocated using the free function; in [C++](https://en.wikipedia.org/wiki/C++), the new operator can be used to allocate memory and the delete operator to deallocate it [(03:30:55)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12655s).
- A memory leak occurs when memory is allocated from the heap but not deallocated when it is no longer needed, causing the application to hold onto unused memory [(03:31:15)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12675s).
- A simple betting game program will be used to simulate the execution in memory and explain the concept of memory leaks [(03:31:46)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12706s).
- The betting game program involves a player guessing the position of the queen in a shuffled deck of three cards, with the player's virtual cash increasing or decreasing based on their wins or losses [(03:31:57)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12717s).
- The program will be implemented using a global variable named cash to store the player's virtual cash, and a variable named bet to store the player's bet amount [(03:32:59)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12779s).
- The game ends when certain conditions are met, such as the bet being zero or the bet being greater than the available cash, and the play function is called to continue the game [(03:33:33)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12813s).
- The play function takes the bet as an argument and declares a character array of size three to represent the cards, with 'J' for Jack, 'Q' for Queen, and 'K' for King [(03:33:43)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12823s).
- The computer performs a randomized shuffling of the cards by making a call to the random number generator function in C, using the srand function to seed the random number generator [(03:34:19)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12859s).
- The shuffling is done by running a loop five times, choosing two random positions in the array, and swapping the characters at those positions [(03:34:38)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12878s).
- The player is asked to guess the position of the Queen, and their input is taken using scanf [(03:36:25)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12985s).
- If the player's guess is correct, their cash is incremented by three times the bet amount; otherwise, their cash is decremented by the bet amount [(03:36:41)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13001s).
- The result of the game is printed, including the player's guess, the actual position of the Queen, and the player's updated cash amount [(03:37:09)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13029s).
- The play function uses a temporary variable to swap the characters at the randomly chosen positions, and the srand function is used to seed the random number generator [(03:35:58)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12958s).
- The concept of seeding the random number generator is mentioned, but not explained in detail [(03:36:14)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=12974s).
- A game executable named "game.txt" was created and run, allowing the user to place bets and play the game, with the balance decreasing after losses and increasing after wins [(03:37:33)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13053s).
- The task manager was used to monitor the memory consumption of the executable, which remained constant at 3408k despite continuous gameplay [(03:38:15)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13095s).
- The code was modified to create a character array on the heap using malloc, with a character pointer named 'C' declared to store the base address of the array [(03:39:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13140s).
- The modified code was run, and the task manager showed an increase in memory consumption from 3408k to 4808k after continuous gameplay [(03:39:45)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13185s).
- The reason for the increase in memory consumption was explained by the difference in memory allocation between the stack and heap, with local variables being allocated on the stack and heap memory being allocated dynamically [(03:40:17)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13217s).
- A diagram of the application's memory sections was used to illustrate how memory is allocated for function execution, with the stack section storing information about function calls and local variables [(03:40:23)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13223s).
- The concept of a stack frame was introduced, with the stack frame of the main function being allocated memory for its execution and local variables, such as the 'bet' variable, being stored within it [(03:40:54)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13254s).
- The process of function calls was explained, with the main function being paused and memory being allocated for the execution of the called function, such as the 'play' function [(03:41:13)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13273s).
- Local variables in a function are stored in a stack frame, which is reclaimed when the function call finishes, so there's no need to worry about deallocation of variables on the stack [(03:41:35)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13295s).
- Each function call has its own stack frame, and the memory allocated for that call is reclaimed when the call finishes [(03:42:05)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13325s).
- When a character array is created on the heap using malloc, a local variable of type pointer to character is created on the stack to point to the memory block on the heap [(03:43:00)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13380s).
- Memory allocated on the heap must be explicitly deallocated using free or delete, as it is not automatically reclaimed when a function call finishes [(03:43:34)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13414s).
- Failing to deallocate unused memory on the heap can lead to memory leaks, which can cause an application's memory consumption to grow over time [(03:44:31)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13471s).
- Memory leaks occur when unused and unreferenced memory blocks accumulate on the heap, and it's the programmer's responsibility to avoid this in languages like C and [C++](https://en.wikipedia.org/wiki/C++) [(03:44:43)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13483s).
- In languages like [Java (programming language)](https://en.wikipedia.org/wiki/Java_(programming_language)) and C#, garbage is automatically cleared from the heap, eliminating the need for manual memory deallocation and reducing the risk of memory leaks [(03:44:55)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13495s).
- A memory leak occurs when the memory consumption of a program increases over time due to the improper use of dynamic memory or the heap section of memory, and it can be prevented by freeing the memory after it is no longer in use [(03:45:15)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13515s).
- In the provided code example, a character array of size 10,000 is created on the heap, but only the first three positions are used, and the memory is freed at the end of the function using the free function [(03:45:19)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13519s).
- If the memory is not freed, the memory consumption would increase significantly, but by freeing the memory, there is no memory leak, and the memory consumption remains stable [(03:45:38)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13538s).
- The memory leak occurs due to unused and unreferenced memory blocks in the heap, and it can be prevented by properly deallocating the memory when it is no longer needed [(03:46:32)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13592s).
- Anything allocated on the stack is deallocated automatically, and the stack is always fixed in size, so memory leaks do not occur on the stack, but rather in the heap [(03:47:02)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13622s).
- To summarize, memory leak is the improper use of dynamic memory that causes the memory consumption of a program to increase over time, and it can be prevented by properly freeing the memory when it is no longer in use [(03:46:50)](https://www.youtube.com/watch?v=zuegQmMdy8M&t=13610s).